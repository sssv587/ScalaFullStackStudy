## 为什么scala中辅助构造器必须要显式调用当前类的主构造器?
- 原因是调用父类构造器
- scala中，只有主构造器可以调用父类构造器
- 多个辅助构造器只需要其中一个显式调用主构造器即可,辅助构造器1中调用了主构造器,则辅助构造器2,3...只需要调用辅助构造器1即可

## 构造器参数不同的写法对属性有什么影响?
- Scala类的主构造器的形参未用任何修饰符修饰，那么这个参数是局部变量。
- 如果参数使用val关键字声明，那么Scala会将参数作为类的私有的只读属性使用 
- 如果参数使用var关键字声明，那么Scala会将参数作为类的成员属性使用,并会提供属性对应的xxx()[类似getter]/xxx_$eq()[类似setter]方法，即这时的成员属性是私有的，但是可读写。

## @BeanProperty修饰属性
- 会自动生成规范的 setXxx/getXxx 方法
- 对原来底层自动生成类似xxx(),xxx_$eq()方法，没有冲突，二者可以共存

## Scala对象创建的流程
- 加载类的信息(属性信息和方法信息), 如果父类也没有加载, 则由父到子加载父类
- 在内存中(堆)给对象开辟空间
- 使用父类的构造器(主构造器/辅助构造器)完成父类的初始化(多个父类)
- 使用本类的主构造器完成初始化
- 使用本类的辅助构造器继续初始化
- 将对象在内存中的地址赋给p这个引用

## Scala中主构造器中的变量的作用范围
- 如果主构造器是Worker(inName: String),那么inName就是一个局部变量
- 如果主构造器是Worker2(val inName: String),那么inName就是Worker2的一个private的只读属性
- 如果主构造器是Worker2(var inName: String),那么inName就是Worker2的一个private的可读写属性

## scala中伴生类和伴生对象的关系
- class + 类名 -> 伴生类  object + 类名 -> 伴生对象
- 伴生类反编译后的是 类名.class 伴生对象反编译后的是 类名$.class
- scala中移除了static关键字，所以class中定义的是非静态属性和方法，object中定义的是静态属性和方法
- scala还是没有生成静态的内容，只不过是将伴生对象生成了一个新的类，实现属性和方法的调用
- 在伴生对象中定义apply方法，可以实现：类名(参数)方式来创建对象实例. 

## scala中包的关键字
- protected 关键字  只有子类和伴生对象中可以使用
- private 关键字 只有当前class关键字和伴生对象中可用
- 包访问权限 private/protected [包名]  等于扩大了包的访问权限

## scala中覆写父类字段的注意事项
- 父类的引用指向子类的对象，根据java方法的动态绑定机制，即方法在被调用时，jvm机会将方法绑定到内存中的对象地址上
- 而scala中的覆写本质上就是重写了get、set方法，所以调用属性时都会调用子类的对象的属性
- 覆写字段时，def只能重写另一个def(即：方法只能重写另一个方法)
- val只能重写父类的一个val属性 或 父类的不带参数的方法
- var只能重写另一个抽象的var属性

## scala创建对象的方式
- new 对象
- apply 方法，创建对象
- 动态混入
- 匿名子类创建对象
- 反射
- 反序列化
- 工具类(Unsafe.allocate)

## scala混入动态特质的执行顺序
- 特质声明从左向右
- 特质方法执行顺序从右到左
  - 细节，可以直接使用super[父特质]的方式直接指定执行顺序
  - 否则，按照从左到右的方式执行super.xxx，直到最后一个特质为止，在调用其父特质方法

## scala中在特质中重写抽象方法有什么意义
- 通过动态混入特质的执行顺序来执行，可以理解为重写抽象方法的类并未完全实现父特质中的抽象方法，需要显式使用abstract
override 来执行该方法为抽象部分实现的方法

## scala特质构造顺序
- 声明类的同时混入特质
  - 调用当前类的超类构造器
  - 第一个特质的父特质构造器
  - 第一个特质构造器
  - 第二个特质构造器的父特质构造器, 如果已经执行过，就不再执行
  - 第二个特质构造器
  - .......重复4,5的步骤(如果有第3个，第4个特质)
  - 当前类构造器
- 在构建对象时，动态混入特质
  - 调用当前类的超类构造器
  - 当前类构造器
  - 第一个特质构造器的父特质构造器
  - 第一个特质构造器.
  - 第二个特质构造器的父特质构造器, 如果已经执行过，就不再执行
  - 第二个特质构造器
  - .......重复5,6的步骤(如果有第3个，第4个特质)
  - 当前类构造器  

## Scala和Java在内部类创建时以及调用内部类方法时的异同
- Java中方法的参数如果使用了内部类类型，不用管是哪个外部类对象创建的，是按照类型来匹配的
- Scala中内部类属于外部类的对象，所以外部类的对象不一样，创建出来的内部类也不一样，这时需要使用类型投影
  - 参数需要改写为 外部类名#内部类名

## 隐式转换什么时候使用?
- 当方法中的参数类型与目标类型不一致时，或者是赋值时
- 当对象调用所在类中不存在的方法或成员时，编译器会自动将对象进行隐式转换

## 什么是偏函数？偏函数的使用规则
- 偏函数可以理解为filter+map的结合体
- 当使用偏函数时，会遍历集合的所有元素，编译器执行流程时先执行isDefinedAt()如果为true ,就会执行apply, 构建一个新的对象返回
- 执行isDefinedAt()为false就过滤掉这个元素，即不构建新的对象
- collect支持偏函数

## 闭包的好处
- 闭包因为可以保留上次引用的某个值，所以我们传入一次就可以反复使用

- Scala引入trait特征 第一可以替代Java的接口,  第二个也是对单继承机制的一种补充