## 为什么scala中辅助构造器必须要显式调用当前类的主构造器?
- 原因是调用父类构造器
- scala中，只有主构造器可以调用父类构造器
- 多个辅助构造器只需要其中一个显式调用主构造器即可,辅助构造器1中调用了主构造器,则辅助构造器2,3...只需要调用辅助构造器1即可

## 构造器参数不同的写法对属性有什么影响?
- Scala类的主构造器的形参未用任何修饰符修饰，那么这个参数是局部变量。
- 如果参数使用val关键字声明，那么Scala会将参数作为类的私有的只读属性使用 
- 如果参数使用var关键字声明，那么Scala会将参数作为类的成员属性使用,并会提供属性对应的xxx()[类似getter]/xxx_$eq()[类似setter]方法，即这时的成员属性是私有的，但是可读写。

## @BeanProperty修饰属性
- 会自动生成规范的 setXxx/getXxx 方法
- 对原来底层自动生成类似xxx(),xxx_$eq()方法，没有冲突，二者可以共存

## Scala对象创建对象流程
- 加载类的信息(属性信息和方法信息), 如果父类也没有加载, 则由父到子加载父类
- 在内存中(堆)给对象开辟空间
- 使用父类的构造器(主构造器/辅助构造器)完成父类的初始化(多个父类)
- 使用本类的主构造器完成初始化
- 使用本类的辅助构造器继续初始化
- 将对象在内存中的地址赋给p这个引用

## Scala中主构造器中的变量的作用范围
- 如果主构造器是Worker(inName: String),那么inName就是一个局部变量
- 如果主构造器是Worker2(val inName: String),那么inName就是Worker2的一个private的只读属性
- 如果主构造器是Worker2(var inName: String),那么inName就是Worker2的一个private的可读写属性

## scala中伴生类和伴生对象的关系
- class + 类名 -> 伴生类  object + 类名 -> 伴生对象
- scala中移除了static关键字，所以class中定义的是非静态属性和方法，object中定义的是静态属性和方法

## scala中包的关键字
- protected 关键字  只有子类和伴生对象中可以使用
- private 关键字 只有当前class关键字和伴生对象中可用
- 包访问权限 private/protected [包名]  等于扩大了包的访问权限